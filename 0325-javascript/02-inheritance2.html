<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>相續2</title>
</head>
<body>
    <script>
    // class내부에 선언되는 constructor생성자는 모든 객체지형언어에서 상속되지 않는다. 만국 공통으로 구조적으로 막는다. 오류방지. 메모리 과소비 보고서 있음.
    
    class Person{
        // parameter
        // 매개변수
        // argument
        // 인자는 모두 동일한 것을 가리킨다. 밑에서 name하고 age가 예가 되고, 객체, 함수, 메서드에 들어가는 내용을 말함

        // 생성자 참조: 상속을 할 시 생성자 함수는 상속되지 않는다.
        // - 상속되지 않는 생성자는 자식 클래스의 생성자에서 참조를 해야 하는데
        //   이를 생성자 참조라고 부른다.
        // - 자식 클래스의 생성자에서는 super(arg1, arg2); 방식으로 부모
        //   생성자 함수의 포맷에서 요구하는 인자에 맞춰서 데이터를 제공해야 한다.
        // - 다만 부모 클래스의 생성자에서 요구하는 인자가 없거나 생성자 선언을
        //  하지  않았을 경우 super는 상황에 따라 생략이 가능한다.
        //  여기서 arg는 argument를 말함. redit에서 이렇게 항상 소통함.
        //   일종의 법과 같은 것인 만약 어기면 너 법을 어겼으니까 실행 안 해줘. 이렇게 나옴.

        constructor(name, age){
            this.name = name;
            this.age = age;
        }
        getName(){return this.name;}
        getAge(){return this.age;}
    };

    class Employee extends Person{
        constructor(name, age, dept){
            super(name, age); // 부모 클래스의 내용을 쓰기 위해 super를 써줌으로써 윗부분의 내용을 참조하도록. 위에 말한 내용을 예로 들은 것임
            this.dept = dept;
        }
        getDept(){return this.dept;}
    };
    
    const emp1= new Employee("John", 37, "Sales");
    console.log(emp1.getName());
    console.log(emp1.getAge());
    console.log(emp1.getDept());
    console.dir(emp1);
</script>
</body>
</html>

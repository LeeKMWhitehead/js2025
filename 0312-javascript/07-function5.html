<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<!-- syntax error: 구문 오류는 컴퓨터 과학 분야에서 특정한 프로그래밍 언어에서
 쓰이도록 고안된 일련의 문자열이나 문자 블록의 구문 속의 오류를 가리킨다.
 컴파일하는 동안 구문 오류가 일어나면 소스 코드가 성공적으로 컴파일할 수 있게 코드를 고쳐야 한다. -->
<body>
    <script>
        // 1 - 매개변수에 함수를 호출하여 해당 함수 안에서 실행시키는 로직 : 콜백함수
        function func1_1(a, func1){
            var x =a; // 2 => x=3;
            var y= func1(2,3); // 3 => y=6
            // y=func1(2,3)

            return x+y; // 5= 3+6=>9
        }

        function func1_2(a, b){
            return a*b; //4
        }

        var val1 = func1_1(3, func1_2); // 실행순서 1
        // 호출하고 결과값을 변수에 할당하는 과정.
        console.log(val1);//정답은?=9      
        
        // 2 - recursive function 함수 자기 자신을 내부에서 호출하여 사용하는 패턴 : 재귀함수
        // 안티로직 : 피해야 하는 로직
        function func2_1(a){
            if (a>=5) return;
            a++;
            console.log(a);
            func2_1(a);
        }

        func2_1(0); // 1 2 3 4 5

        //3 directly exection function 함수를 선언하는 즉시 실행하는 함수 : 실행함수
        (function func3_1(a, b){
            console.log(a+b);
        })(3,5); //8

        // 4 - closure 설명하는 도입부
        function func4_1(){
            let x=1;
            function func4_2(){
                console.log(x);
            }
            return func4_2;
        }
        let func4_3 = func4_1();
        func4_3();// 정답은 1

        // 4- 내부의 데이터에접근을 막고 함수의 기능을
        // 동작시키도록 하는 특수 정의 형태 - closure(클로저)
        const func4_1 = function(){ //재선언 재할당 불가 장치가 바로 const
            let x=1;
            function func4_2(){
                console.log(x);
            }
            return func4_2;
        }
        let func4_3 = func4_1();
        func4_3();// 정답은 1

    </script>
</body>
</html>